## 概述

`bpftrace` 语言受到了 D 语言的启发用了相同的语法结构，每个脚本包含一个前言和一个或多个动作块。

```c
preamble

actionblock1
actionblock2
```

预处理和类型定义在前言中：

```c
#include <linux/socket.h>
#define RED "\033[31m]"

struct S{
    int x;
}
```

每个动作块由三部分组成：

```c
probe[,probe]
/predicate/ {
    action
}
```

每个动作块可以有多个探测点，探测点之间由逗号',' 链接。 



| 语法      | 解释                                                         |
| --------- | ------------------------------------------------------------ |
| probe     | 一个probe指定了要绑定的事件和事件类型                        |
| predicate | 只有predicate满足的时候action 才会被执行                     |
| action    | action是事件触发时候执行的动作，动作由中括号在内的一系列语句组成 |



```c
BEGIN
{
    printf("Tracing open syscalls... Hit Ctrl-C to end.\n");
}

tracepoint:syscalls:sys_enter_open,
tracepoint:syscalls:sys_enter_openat
{
    printf("%-6d %-16s %s\n", pid, comm, str(args->filename));
}
```

上边的例子有有两个动作块和总共3 个探测点组成。

第一个动作块是BEGIN，该动作在bpftrace 刚开始的时候执行，用于打印一个表头信息。

第二个动作块有两个探测点，一个是`open` 另一个是`openat`，定义了一个输出进程号、进程名、文件名的动作。

## 标识符

标识符必须满足这个正则标识式：`[_a-zA-Z][_a-zA-Z0-9]*`

## 注释

同时支持单行和多行注释。

```c
//单行注释

/*
 * 多行注释
 */
```

## 数据类型

| 类型   | 描述           |
| ------ | -------------- |
| uint8  | 无符号8位整形  |
| int8   | 有符号8位整形  |
| uint16 | 无符号16位整形 |
| int16  | 有符号16位整形 |
| uint32 | 无符号32位整形 |
| int32  | 有符号32位整形 |
| uint64 | 无符号64位整形 |
| int64  | 有符号64位整形 |

### 浮点型

不支持。

## 常量

* 十进制
* 八进制
* 十六进制
* 科学计数法(10进制)

## 字符

字符可以通过定义在单引号里的字符表示。

## 字符串

字符串可以通过定义在双引号里的字符串表示。

| 转移序列 | 解释          |
| -------- | ------------- |
| \n       | 环行          |
| \t       | Tab           |
| \0nn     | 八进制数 nn   |
| \xnn     | 十六进制数 nn |

## 类型转换

```c
$y = (uint32)$z;
```

## 运算符和表达式

| 运算符 | 解释       |
| ------ | ---------- |
| +      | 加         |
| -      | 减         |
| *      | 乘         |
| /      | 除         |
| %      | 取余       |
| &&     | 逻辑与     |
| \|\|   | 逻辑或     |
| !      | 逻辑非     |
| &      | 位与       |
| \|     | 位或       |
| ^      | 位非       |
| <<     | 位左移操作 |
| \>\>   | 位右移操作 |
| <      | 小于       |
| <=     | 小于等于   |
| >      | 大于       |
| >=     | 大于等于   |
| ==     | 等于       |
| !=     | 不等于     |

**字符串比较**

| 符号 | 解释   |
| ---- | ------ |
| ==   | 等于   |
| !=   | 不等于 |

**赋值运算符**

| 符号  | 解释 |
| ----- | ---- |
| =     | 略   |
| <<=   | 略   |
| \>\>= | 略   |
| +=    | 略   |
| -=    | 略   |
| *=    | 略   |
| /=    | 略   |
| %=    | 略   |
| &=    | 略   |
| \|=   | 略   |
| ^=    | 略   |

**递增递减运算符**

| 运算符号 | 解释    |
| -------- | ------- |
| ++       | 同C语言 |
| --       | 同C语言 |



## 变量和映射

`bpftrace` 支持两种数据类型，`scratch` 和`map`。

### scratch 变量

`scratch` 在BPF 栈中，仅仅在action 块执行的时候才可以访问，不能被程序外访问，`scratch` 变量由`$` 开始，例如`$myvar`。

### map变量

* `map` 变量使用BPF `map`，在程序运行期间程序内的所有action 块都可以访问，用户态程序也可以访问。
* `Map`名称以`@` 开头，例如`@mymap`；程序中常见单独一个`@` 类型的`map`变量。
* 数据类型在第一次定义的时候自动决定，之后不能被更改。



### 关联数组

关联数组类似与C++ 中的`map` 和 Python 中的`dict` ，是`map` 数据类型。

```c
@name[key] = expression
```

一旦定义之后，`key` 和 `value` 的数值都将不能再改变。



## 变量作用域

## 指针

与`C` 语言中类似。

## 元组

元组是不可变的，每个元组元素可以有不同数据类型，可以通过 `.` 符号访问。

## 数组

不支持从零开始创建数组，仅支持从指针中获取变量。

## 结构体

不支持从零开始创建，仅仅支持从指针中读取变量。

## 条件语句

支持 `if/else` 和三元运算符。

```c
//三元运算符
condition ? ifTrue : ifFalse

//条件语句
if (condition) {
    ifblock
} else if (condition) {
    if2block
} else {
    elseblock
}
```

## 循环

```c
//while 循环
while (condition) {
    block;
}

//unroll 语句
//计算 n 并展开，等同于执行 n 次 block;
unroll(n) {
    block;
}
```


