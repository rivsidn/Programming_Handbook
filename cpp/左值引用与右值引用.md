

## 附录

### AI

> 左值引用和右值引用之间有什么差异

● 左值引用和右值引用是C++11引入的重要概念，它们有本质差异：

  基本定义

  左值引用：& - 绑定到左值（有名称、可取地址的对象）
  右值引用：&& - 绑定到右值（临时对象、字面量）

  语法示例

  int x = 10;
  int& lref = x;          // 左值引用，绑定到变量x
  int&& rref = 20;        // 右值引用，绑定到字面量20
  int&& rref2 = x + 5;    // 右值引用，绑定到表达式结果（临时对象）

  // int& bad = 20;       // 错误：左值引用不能绑定右值
  // int&& bad2 = x;      // 错误：右值引用不能绑定左值

  主要差异

  1. 绑定对象不同
  std::string str = "hello";
  std::string& lref = str;           // 绑定到已存在的对象
  std::string&& rref = "world";      // 绑定到临时字符串对象

  2. 移动语义支持
  class MyString {
      char* data;

  public:
      // 拷贝构造函数（左值引用）
      MyString(const MyString& other) {
          // 深拷贝：分配新内存，复制数据
          data = new char[strlen(other.data) + 1];
          strcpy(data, other.data);
      }

      // 移动构造函数（右值引用）
      MyString(MyString&& other) noexcept {
          // 移动：直接"偷"资源，避免拷贝
          data = other.data;
          other.data = nullptr;  // 清空源对象
      }
  };

  MyString s1("hello");
  MyString s2 = s1;           // 调用拷贝构造函数
  MyString s3 = std::move(s1); // 调用移动构造函数

  3. 生命周期管理
  const std::string& lref = get_string();  // 左值引用延长临时对象生命周期
  std::string&& rref = get_string();       // 右值引用也延长生命周期

  // 但是：
  void func(const std::string& s) {}  // 参数可以接受左值和右值
  void func(std::string&& s) {}       // 参数只接受右值

  实际应用场景

  移动构造/赋值
  std::vector<int> create_vector() {
      return std::vector<int>(1000, 42);  // 返回临时对象
  }

  std::vector<int> v = create_vector();   // 移动，而不是拷贝

  完美转发
  template<typename T>
  void wrapper(T&& arg) {  // 万能引用
      func(std::forward<T>(arg));  // 完美转发，保持原始类型
  }

  函数重载
  void process(const std::string& s) {
      std::cout << "处理左值: " << s << std::endl;
  }

  void process(std::string&& s) {
      std::cout << "处理右值: " << s << std::endl;
  }

  std::string str = "hello";
  process(str);              // 调用左值版本
  process("world");          // 调用右值版本
  process(std::move(str));   // 强制调用右值版本

  核心价值

  性能优化：右值引用允许"移动"而不是"拷贝"，大幅提升大对象的性能
  语义清晰：区分资源的所有权转移和共享访问

